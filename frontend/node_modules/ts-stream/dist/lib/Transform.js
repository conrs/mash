"use strict";
/**
 * Promise-based object stream with seamless support for back-pressure and error
 * handling, written in Typescript.
 *
 * Copyright (C) 2015 Martin Poelstra
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.filter = exports.map = exports.compose = void 0;
var Stream_1 = require("./Stream");
function compose(t1, t2) {
    return function (readable, writable) {
        var stream = new Stream_1.Stream();
        t1(readable, stream);
        t2(stream, writable);
    };
}
exports.compose = compose;
// Return an ender callback that first runs an optional user-supplied ender,
// followed by the default ender that always ends the stream.
// It's refactored out, because it's currently a bit tricky and exact behavior
// may change, see TODO in implementation.
function composeEnders(ender, defaultEnder) {
    if (!ender) {
        return defaultEnder;
    }
    return function (error) {
        // TODO: an error returned from ender is currently passed on to next
        // stream, if stream was not ended with an error yet.
        // It'd maybe be better to not have the next stream be ended when an
        // error occurred in this ender, but there's no way to send another
        // end(), so we have to close it somehow...
        return Promise.resolve(error)
            .then(ender)
            .then(function () { return defaultEnder(error); }, function (enderError) {
            // ender callback failed, but in order to let final stream fail,
            // we need to pass 'something' on, and to wait for that to come
            // back.
            // Finally, make sure to return the enderError.
            return Promise.resolve(defaultEnder(error || enderError)).then(function () { return Promise.reject(enderError); }, function () { return Promise.reject(enderError); });
        });
    };
}
function map(readable, writable, mapper, ender, aborter) {
    writable.aborted().catch(function (err) { return readable.abort(err); });
    readable.aborted().catch(function (err) { return writable.abort(err); });
    readable.forEach(function (v) { return writable.write(mapper(v)); }, composeEnders(ender, function (error) {
        return writable.end(error, readable.result());
    }), aborter);
}
exports.map = map;
function filter(readable, writable, filterer, ender, aborter) {
    writable.aborted().catch(function (err) { return readable.abort(err); });
    readable.aborted().catch(function (err) { return writable.abort(err); });
    readable.forEach(function (v) {
        var b = filterer(v);
        if (!b) {
            return;
        }
        else if (b === true) {
            // note: not just `if (b)`!
            return writable.write(v);
        }
        else {
            // more complex return type, probably a PromiseLike
            return Promise.resolve(b).then(function (resolvedB) {
                if (resolvedB) {
                    return writable.write(v);
                }
            });
        }
    }, composeEnders(ender, function (error) {
        return writable.end(error, readable.result());
    }), aborter);
}
exports.filter = filter;
//# sourceMappingURL=Transform.js.map